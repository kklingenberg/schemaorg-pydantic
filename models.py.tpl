"""Pydantic models generated from the schema.org vocabulary version
{{ schemaorg_version }}. See https://schema.org for reference.

Generated by schemaorg-pydantic@{{ commit }}
at {{ timestamp }}

This file was created by a [Typer](https://github.com/tiangolo/typer)-enabled
python program which uses [Jinja2](https://jinja.palletsprojects.com/) templates
to generate the pydantic models file{% if not skip_black %} and format it through
[black](https://github.com/psf/black){% endif %}.

Typer version: {{ typer_version }}
Jinja2 version: {{ jinja2_version }}{% if not skip_black %}
black version: {{ black_version }}{% endif %}

"""
from datetime import date, datetime, time
from decimal import Decimal
from enum import Enum
from typing import Any, List, Literal, Optional, Union

from pydantic import AnyUrl, BaseModel, Field, StrictBool


class SchemaOrgBase(BaseModel):

    def dict(self, *args, **kwargs):
        defaults = {
            "exclude_none": True,
            "by_alias": True
        }
        return super().dict(*args, **dict(defaults, **kwargs))

    class Config:
        allow_population_by_field_name = True


{% for enum in enums %}
class {{ enum.name }}(str, Enum):
    """{{ enum.formatted_description }}

    See https://schema.org/{{ enum.schema_name }}.

    """

    {%- for member in enum.members %}
    {{ member.name }} = "https://schema.org/{{ member.schema_name }}"
    {%- endfor %}

{% endfor %}


{% for model in models %}
class {{ model.name }}(SchemaOrgBase):
    """{{ model.formatted_description }}

    See https://schema.org/{{ model.schema_name }}.

    """

    {%- for field in model.fields %}
    {{ field.name }}: {{ field.type }} = Field(
        None,
        {% if field.schema_name != field.name %}alias="{{ field.schema_name }}",{% endif %}
        description={{ field.formatted_description }},
    )
    {%- endfor %}
    locals().update({"@type": Field("{{ model.schema_name }}", const="{{ model.schema_name }}")})

{% endfor %}


{%- for model in models %}
{{ model.name }}.update_forward_refs()
{%- endfor %}

if __name__ == "__main__":
    {%- for model in models %}
    {# Idempotency #}
    obj = {{ model.name }}.construct(name="foo", description=["bar", "baz"])
    assert obj.dict() == {{ model.name }}.parse_obj(obj.dict()).dict()
    {# Check dict lists are parsed as dicts, and not as as lists of dict keys #}
    {%- if model.name == "Product" %}
    product = Product(name="foo", isConsumableFor=Product(name="bar"))
    assert product.dict() == Product.parse_obj(product.dict()).dict()
    product_list = Product(name="foo", isConsumableFor=[Product(name="bar")])
    assert product_list.dict() == Product.parse_obj(product_list.dict()).dict()
    {%- endif %}
    {# Check string of numbers are parsed as numbers and not as lists #}
    {% if model.name == "QuantitativeValue" %}
    quantitative_value = {"name": "foo", "maxValue": "123", "@type": "QuantitativeValue"}
    assert QuantitativeValue.parse_obj(quantitative_value).dict()["maxValue"] == 123
    {%- endif %}
    {%- endfor %}
